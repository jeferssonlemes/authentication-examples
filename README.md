# üõ°Ô∏è JWT Authentication & Security Examples

Este projeto demonstra a implementa√ß√£o abrangente de m√∫ltiplas camadas de seguran√ßa em uma aplica√ß√£o ASP.NET Core, incluindo autentica√ß√£o JWT, prote√ß√£o CSRF, headers de seguran√ßa, preven√ß√£o XSS e muito mais.

## üìã √çndice

- [Vis√£o Geral da Arquitetura de Seguran√ßa](#-vis√£o-geral-da-arquitetura-de-seguran√ßa)
- [Camadas de Seguran√ßa Implementadas](#-camadas-de-seguran√ßa-implementadas)
- [Fluxo de Autentica√ß√£o](#-fluxo-de-autentica√ß√£o)
- [Prote√ß√µes Implementadas](#-prote√ß√µes-implementadas)
- [Como Executar](#-como-executar)
- [Testes de Seguran√ßa](#-testes-de-seguran√ßa)
- [Estrutura do Projeto](#-estrutura-do-projeto)

## üèóÔ∏è Vis√£o Geral da Arquitetura de Seguran√ßa

Este projeto implementa um sistema de seguran√ßa em m√∫ltiplas camadas, cada uma com responsabilidades espec√≠ficas:

### üîí Camadas de Seguran√ßa por N√≠vel

```mermaid
graph TB
    Client[Cliente/Browser]
    
    subgraph "Frontend Security Layer"
        XSS[XSS Protection JS]
        CSRF_CLIENT[CSRF Helper]
        INPUT_SANITIZATION[Input Sanitization]
    end
    
    subgraph "Transport Security Layer"
        HTTPS[HTTPS/TLS]
        CORS[CORS Policy]
        HEADERS[Security Headers]
    end
    
    subgraph "Application Security Layer"
        JWT[JWT Authentication]
        ANTIFORGERY[Anti-Forgery Tokens]
        AUTHORIZATION[Authorization Policies]
    end
    
    subgraph "Middleware Security Layer"
        EXCEPTION[Exception Handling]
        STATUS_CODES[Status Code Pages]
        HEADER_MIDDLEWARE[Security Headers Middleware]
    end
    
    subgraph "Backend Security Layer"
        INPUT_VALIDATION[Server Input Validation]
        XSS_DETECTION[XSS Detection]
        LOGGING[Security Logging]
    end
    
    Client --> Frontend
    Frontend --> Transport
    Transport --> Application
    Application --> Middleware
    Middleware --> Backend
```

## üõ°Ô∏è Camadas de Seguran√ßa Implementadas

### 1. **Autentica√ß√£o JWT (JSON Web Tokens)**

#### üìç Localiza√ß√£o

- `Extensions/AuthenticationExtensions.cs`
- `Services/AuthService.cs`
- `Controllers/AuthController.cs`

#### üîß Implementa√ß√£o

```csharp
// Configura√ß√£o JWT
builder.Services.AddJwtAuthentication(builder.Configuration);

// Gera√ß√£o de token
var token = _jwtService.GenerateToken(user.Username, user.Role);
```

#### ‚úÖ Benef√≠cios

- **Stateless**: N√£o requer armazenamento de sess√£o no servidor
- **Escal√°vel**: Funciona bem em ambientes distribu√≠dos
- **Seguro**: Tokens assinados digitalmente
- **Flex√≠vel**: Suporte a diferentes roles e claims

---

### 2. **Prote√ß√£o CSRF (Cross-Site Request Forgery)**

#### üìç Localiza√ß√£o

- `Program.cs` (configura√ß√£o)
- `Controllers/AntiForgeryController.cs`
- `wwwroot/js/csrf-helper.js`

#### üîß Implementa√ß√£o

```csharp
// Configura√ß√£o Anti-Forgery
builder.Services.AddAntiforgery(options =>
{
    options.HeaderName = "X-CSRF-TOKEN";
    options.Cookie.HttpOnly = true;
    options.Cookie.SecurePolicy = CookieSecurePolicy.SameAsRequest;
    options.Cookie.SameSite = SameSiteMode.Strict;
});
```

#### ‚úÖ Benef√≠cios

- **Preven√ß√£o de CSRF**: Impede ataques de requisi√ß√µes forjadas
- **Token por requisi√ß√£o**: Cada requisi√ß√£o tem seu pr√≥prio token
- **Cookie seguro**: Configura√ß√µes rigorosas de seguran√ßa
- **API friendly**: Suporte tanto para forms quanto para APIs

---

### 3. **Headers de Seguran√ßa**

#### üìç Localiza√ß√£o

- `Extensions/SecurityHeadersExtensions.cs`

#### üîß Implementa√ß√£o

```csharp
app.Use(async (context, next) =>
{
    // Verifica√ß√£o de duplica√ß√£o para evitar erro em re-execu√ß√£o
    if (!context.Response.Headers.ContainsKey("X-Content-Type-Options"))
        context.Response.Headers.Add("X-Content-Type-Options", "nosniff");
    
    if (!context.Response.Headers.ContainsKey("X-Frame-Options"))
        context.Response.Headers.Add("X-Frame-Options", "DENY");
    
    if (!context.Response.Headers.ContainsKey("X-XSS-Protection"))
        context.Response.Headers.Add("X-XSS-Protection", "1; mode=block");
    
    if (!context.Response.Headers.ContainsKey("Content-Security-Policy"))
        context.Response.Headers.Add("Content-Security-Policy", 
            "default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net...");
    
    await next();
});
```

#### ‚úÖ Headers Implementados

- **X-Content-Type-Options**: Previne MIME type sniffing
- **X-Frame-Options**: Previne clickjacking  
- **X-XSS-Protection**: Ativa prote√ß√£o XSS do browser
- **Content-Security-Policy**: Pol√≠tica rigorosa de conte√∫do
- **Referrer-Policy**: Controla informa√ß√µes de referrer

---

### 4. **Prote√ß√£o XSS (Cross-Site Scripting)**

#### üìç Localiza√ß√£o

- `wwwroot/js/xss-protection.js`
- `Controllers/SecurityController.cs`

#### üîß Implementa√ß√£o Frontend

```javascript
class XSSProtection {
    escapeHtml(unsafe) {
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }
    
    sanitizeText(text) {
        const dangerous = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;
        return this.escapeHtml(text.replace(dangerous, ""));
    }
}
```

#### üîß Implementa√ß√£o Backend

```csharp
private bool DetectXSSAttempt(string input)
{
    var suspiciousPatterns = new[]
    {
        "<script", "javascript:", "onload=", "onclick=", 
        "eval(", "alert(", "document.cookie"
    };
    
    return suspiciousPatterns.Any(pattern =>
        input.Contains(pattern, StringComparison.OrdinalIgnoreCase));
}
```

#### ‚úÖ Benef√≠cios

- **Detec√ß√£o proativa**: Identifica tentativas de XSS
- **Sanitiza√ß√£o autom√°tica**: Limpa inputs perigosos
- **Logging**: Registra tentativas de ataque
- **Dupla prote√ß√£o**: Frontend + Backend

---

### 5. **Autoriza√ß√£o Baseada em Pol√≠ticas**

#### üìç Localiza√ß√£o

- `Extensions/AuthorizationExtensions.cs`
- `Requirements/` (custom requirements)
- `Handlers/` (authorization handlers)

#### üîß Implementa√ß√£o

```csharp
builder.Services.AddPermissionPolicies();

// Pol√≠ticas customizadas
services.AddAuthorization(options =>
{
    options.AddPolicy("AdminOnly", policy =>
        policy.RequireRole("Admin"));
        
    options.AddPolicy("UserOrAdmin", policy =>
        policy.RequireRole("User", "Admin"));
});
```

#### ‚úÖ Benef√≠cios

- **Granularidade**: Controle fino de acesso
- **Flexibilidade**: Pol√≠ticas customiz√°veis
- **Reutiliza√ß√£o**: Pol√≠ticas aplic√°veis em m√∫ltiplos endpoints
- **Manutenibilidade**: L√≥gica centralizada

---

### 6. **Middleware de Tratamento de Exce√ß√µes**

#### üìç Localiza√ß√£o

- `Middlewares/ExceptionHandlingMiddleware.cs`

#### üîß Implementa√ß√£o

```csharp
public async Task InvokeAsync(HttpContext context)
{
    try
    {
        await _next(context);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Erro n√£o tratado ocorreu.");
        await HandleExceptionAsync(context, ex);
    }
}
```

#### ‚úÖ Benef√≠cios

- **Tratamento centralizado**: Um local para todas as exce√ß√µes
- **Logging**: Registro detalhado de erros
- **Resposta adequada**: JSON para APIs, redirecionamento para web
- **Seguran√ßa**: N√£o vaza informa√ß√µes sens√≠veis

---

### 7. **Rate Limiting (Limita√ß√£o de Taxa)**

#### üìç Localiza√ß√£o

- `Extensions/RateLimitingExtensions.cs`
- `Controllers/RateLimitController.cs`
- `Views/Home/RateLimit.cshtml`
- `wwwroot/js/rate-limit-tests.js`

#### üîß Estrutura Base

```csharp
services.AddRateLimiter(rateLimiterOptions =>
{
    // Cada pol√≠tica usa uma partition key (normalmente IP)
    partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown"
    
    // Configura√ß√£o do comportamento quando limite √© excedido
    rateLimiterOptions.OnRejected = async (context, _) => {
        // Log + Headers + Resposta personalizada (429)
    };
});
```

#### üéØ **Pol√≠ticas Implementadas**

##### **1. GeneralPolicy - Sliding Window (Janela Deslizante)**

```csharp
rateLimiterOptions.AddPolicy("GeneralPolicy", httpContext =>
    RateLimitPartition.GetSlidingWindowLimiter(
        partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
        factory: _ => new SlidingWindowRateLimiterOptions
        {
            PermitLimit = 100,              // üéØ 100 requisi√ß√µes permitidas
            Window = TimeSpan.FromMinutes(1), // ‚è∞ Janela de 1 minuto
            SegmentsPerWindow = 6,          // üìä Divide em 6 segmentos (10s cada)
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
            QueueLimit = 10                 // üö™ Fila de 10 requisi√ß√µes
        }));
```

**Como funciona:**

- **Janela Deslizante**: Sempre olha os √∫ltimos 60 segundos
- **Segmentos**: 6 per√≠odos de 10s cada (0-10s, 10-20s, 20-30s, etc.)
- **Distribui√ß√£o Suave**: Evita "rajadas" no in√≠cio de cada minuto
- **Exemplo**: Se fez 60 req nos primeiros 30s, s√≥ pode fazer 40 nos pr√≥ximos 30s

##### **2. AuthPolicy - Fixed Window (Janela Fixa)**

```csharp
rateLimiterOptions.AddPolicy("AuthPolicy", httpContext =>
    RateLimitPartition.GetFixedWindowLimiter(
        partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
        factory: _ => new FixedWindowRateLimiterOptions
        {
            PermitLimit = 5,                // üéØ 5 tentativas de login
            Window = TimeSpan.FromMinutes(5), // ‚è∞ Janela fixa de 5 minutos
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
            QueueLimit = 0                  // üö´ SEM fila - rejeita imediatamente
        }));
```

**Como funciona:**

- **Janela Fixa**: Reinicia do zero a cada 5 minutos
- **Sem Fila**: 6¬™ tentativa = 429 imediato (ideal para login)
- **Reset Completo**: 12:00-12:05 (5 tentativas) ‚Üí 12:05-12:10 (reset completo)
- **Prote√ß√£o Brute Force**: Previne ataques de for√ßa bruta

##### **3. StrictPolicy - Token Bucket (Balde de Tokens)**

```csharp
rateLimiterOptions.AddPolicy("StrictPolicy", httpContext =>
    RateLimitPartition.GetTokenBucketLimiter(
        partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
        factory: _ => new TokenBucketRateLimiterOptions
        {
            TokenLimit = 10,                // ü™£ Balde comporta 10 tokens
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
            QueueLimit = 2,                 // üö™ Fila pequena de 2
            ReplenishmentPeriod = TimeSpan.FromSeconds(30), // ‚è±Ô∏è Reabastece a cada 30s
            TokensPerPeriod = 2,            // ‚ûï Adiciona 2 tokens por per√≠odo
            AutoReplenishment = true        // üîÑ Reabastece automaticamente
        }));
```

**Como funciona:**

- **Consumo de Tokens**: Cada requisi√ß√£o "gasta" 1 token
- **Reabastecimento**: +2 tokens a cada 30 segundos
- **Rajadas Permitidas**: Pode fazer 10 requisi√ß√µes seguidas (se tiver tokens)
- **Controle Sustentado**: For√ßa uma taxa m√°xima sustent√°vel (4 req/min)

##### **4. ConcurrencyPolicy - Concurrency Limiter (Limitador Simult√¢neo)**

```csharp
rateLimiterOptions.AddPolicy("ConcurrencyPolicy", httpContext =>
    RateLimitPartition.GetConcurrencyLimiter(
        partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
        factory: _ => new ConcurrencyLimiterOptions
        {
            PermitLimit = 5,                // üîÑ 5 requisi√ß√µes simult√¢neas
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
            QueueLimit = 10                 // üö™ 10 esperando na fila
        }));
```

**Como funciona:**

- **N√£o √© sobre tempo**: √â sobre quantas est√£o processando simultaneamente
- **Quando termina uma**: Libera espa√ßo para pr√≥xima da fila
- **Ideal para opera√ß√µes longas**: Upload, processamento, etc.
- **Controla recursos**: Evita sobrecarga do servidor

##### **5. TestPolicy - Sliding Window (Para Testes)**

```csharp
rateLimiterOptions.AddPolicy("TestPolicy", httpContext =>
    RateLimitPartition.GetSlidingWindowLimiter(
        partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
        factory: _ => new SlidingWindowRateLimiterOptions
        {
            PermitLimit = 20,               // üéØ 20 requisi√ß√µes por minuto
            Window = TimeSpan.FromMinutes(1), // ‚è∞ 1 minuto
            SegmentsPerWindow = 4,          // üìä 4 segmentos (15s cada)
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
            QueueLimit = 3                  // üö™ Fila pequena para demonstra√ß√£o
        }));
```

**Comportamento no seu teste:**

- **Requisi√ß√µes 1-20**: ‚úÖ Processadas normalmente
- **Requisi√ß√£o 21**: ‚è≥ Vai para fila (posi√ß√£o 1/3)
- **Requisi√ß√µes 22-23**: ‚è≥ V√£o para fila (posi√ß√µes 2/3 e 3/3)
- **Requisi√ß√£o 24+**: ‚ùå 429 (fila cheia)

##### **6. NoQueuePolicy - Fixed Window (Rejei√ß√£o Imediata)**

```csharp
rateLimiterOptions.AddPolicy("NoQueuePolicy", httpContext =>
    RateLimitPartition.GetFixedWindowLimiter(
        partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
        factory: _ => new FixedWindowRateLimiterOptions
        {
            PermitLimit = 5,                // üéØ 5 requisi√ß√µes por minuto
            Window = TimeSpan.FromMinutes(1), // ‚è∞ 1 minuto
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
            QueueLimit = 0                  // üö´ SEM fila - 429 imediato
        }));
```

**Como funciona:**

- **Zero Toler√¢ncia**: 6¬™ requisi√ß√£o = 429 na hora
- **Demonstra√ß√£o**: Mostra diferen√ßa entre fila vs sem fila
- **Ideal para**: APIs cr√≠ticas que n√£o podem ter delay

##### **7. GlobalLimiter - Fallback Global**

```csharp
rateLimiterOptions.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, string>(
    httpContext => RateLimitPartition.GetSlidingWindowLimiter(
        partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
        factory: _ => new SlidingWindowRateLimiterOptions
        {
            PermitLimit = 200,              // üåê 200 requisi√ß√µes por IP
            Window = TimeSpan.FromMinutes(1),
            SegmentsPerWindow = 6,
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
            QueueLimit = 50                 // üö™ Fila global generosa
        }));
```

**Como funciona:**

- **Fallback**: Usado quando endpoint n√£o tem pol√≠tica espec√≠fica
- **Por IP**: Cada IP tem seu pr√≥prio limite de 200/min
- **Prote√ß√£o Geral**: √öltima linha de defesa

#### üîß **Configura√ß√µes Importantes**

##### **Partition Key (Chave de Parti√ß√£o)**

```csharp
partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown"
```

- **Por IP**: Cada IP tem contadores separados
- **Isolamento**: IP 192.168.1.1 n√£o afeta limites do IP 192.168.1.2
- **Fallback**: "unknown" se n√£o conseguir determinar o IP

##### **Queue Processing Order (Ordem da Fila)**

```csharp
QueueProcessingOrder = QueueProcessingOrder.OldestFirst  // FIFO
QueueProcessingOrder = QueueProcessingOrder.NewestFirst // LIFO
```

##### **OnRejected (Comportamento ao Rejeitar)**

```csharp
rateLimiterOptions.OnRejected = async (context, _) =>
{
    var httpContext = context.HttpContext;
    
    // Log detalhado
    logger?.LogWarning("üö´ Rate Limit Exceeded: {IP} - {Path} - Reason: {Reason}", 
        httpContext.Connection.RemoteIpAddress,
        httpContext.Request.Path,
        context.Reason);
    
    // Headers informativos
    httpContext.Response.Headers["Retry-After"] = "60";
    httpContext.Response.Headers["X-RateLimit-Reason"] = context.Reason.ToString();
    
    // Resposta diferenciada
    if (httpContext.Request.Path.StartsWithSegments("/api"))
    {
        // Para APIs: JSON estruturado
        var response = new {
            error = "Rate limit exceeded",
            reason = context.Reason.ToString(),
            tip = context.Reason == RateLimitReasonPhrase.QueueLimitExceeded 
                ? "Queue is full. Try again when current requests complete."
                : "Rate limit exceeded. Wait before making new requests."
        };
        await httpContext.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
    else
    {
        // Para p√°ginas web: mensagem simples
        await httpContext.Response.WriteAsync($"Rate limit exceeded: {context.Reason}");
    }
};
```

#### üìä **Compara√ß√£o dos Algoritmos**

| Algoritmo | Uso Ideal | Distribui√ß√£o | Rajadas | Fila |
|-----------|-----------|--------------|---------|------|
| **Sliding Window** | Distribui√ß√£o suave | ‚úÖ Uniforme | ‚ùå Limitadas | ‚úÖ Sim |
| **Fixed Window** | Controle rigoroso | ‚ùå Pode ter picos | ‚úÖ Permitidas no in√≠cio | ‚ö†Ô∏è Opcional |
| **Token Bucket** | Rajadas controladas | ‚ö†Ô∏è Moderada | ‚úÖ At√© o limite do balde | ‚úÖ Sim |
| **Concurrency** | Opera√ß√µes longas | N/A | N/A | ‚úÖ Sim |

#### ‚úÖ **Benef√≠cios Implementados**

- **üõ°Ô∏è Prote√ß√£o DoS/DDoS**: M√∫ltiplas camadas de prote√ß√£o
- **üéØ Pol√≠ticas Espec√≠ficas**: Diferentes limites para diferentes necessidades
- **üìä M√∫ltiplos Algoritmos**: Sliding Window, Fixed Window, Token Bucket, Concurrency
- **üîç Monitoramento**: Logs detalhados e headers informativos
- **‚ö° Performance**: Rate limiting nativo do .NET (alta performance)
- **üåê Particionamento**: Por IP para isolamento de usu√°rios
- **üö™ Controle de Fila**: Configur√°vel por pol√≠tica
- **üìà M√©tricas**: Headers de resposta com informa√ß√µes de limite

---

### 8. **Configura√ß√£o CORS**

#### üìç Localiza√ß√£o

- `Program.cs`

#### üîß Implementa√ß√£o

```csharp
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader()
              .WithExposedHeaders("X-CSRF-TOKEN");
    });
});
```

#### ‚úÖ Benef√≠cios

- **Controle de origem**: Define quais dom√≠nios podem acessar a API
- **Headers personalizados**: Exp√µe headers necess√°rios (CSRF)
- **Flexibilidade**: Diferentes pol√≠ticas para diferentes cen√°rios

## üîÑ Fluxo de Autentica√ß√£o

```mermaid
sequenceDiagram
    participant U as User
    participant C as Client
    participant MW as Middleware
    participant Auth as AuthController
    participant JWT as JWTService
    participant API as Protected API

    U->>C: 1. Login Request
    C->>Auth: 2. POST /api/auth/login
    Auth->>JWT: 3. Generate Token
    JWT-->>Auth: 4. JWT Token
    Auth-->>C: 5. Token + User Info
    C->>C: 6. Store JWT in localStorage
    
    Note over C: Subsequent API calls
    C->>MW: 7. API Request + Bearer Token
    MW->>MW: 8. Validate JWT
    alt Valid Token
        MW->>API: 9. Forward Request
        API-->>MW: 10. Response
        MW-->>C: 11. Response
    else Invalid Token
        MW-->>C: 12. 401 Unauthorized
    end
```

## üõ†Ô∏è Fluxo de Prote√ß√£o CSRF

```mermaid
sequenceDiagram
    participant C as Client
    participant CSRF as CSRF Controller
    participant MW as Middleware
    participant API as Protected API

    C->>CSRF: 1. GET /api/antiforgery/token
    CSRF-->>C: 2. CSRF Token + Cookie
    C->>C: 3. Store token
    
    Note over C: Protected operation
    C->>MW: 4. POST with X-CSRF-TOKEN header
    MW->>MW: 5. Validate CSRF token
    alt Valid CSRF
        MW->>API: 6. Forward request
        API-->>MW: 7. Response
        MW-->>C: 8. Success response
    else Invalid CSRF
        MW-->>C: 9. 400 Bad Request
    end
```

## üîç Pipeline de Seguran√ßa

```mermaid
flowchart TD
    START([Request Iniciada]) --> RATE_LIMIT{Rate Limit Check}
    RATE_LIMIT -->|Exceeded| RATE_BLOCK[‚ùå 429 Rate Limited]
    RATE_LIMIT -->|OK| CORS{CORS Check}
    
    CORS -->|Allow| HEADERS[Add Security Headers]
    CORS -->|Block| BLOCK1[‚ùå CORS Blocked]
    
    HEADERS --> HTTPS{HTTPS?}
    HTTPS -->|No| REDIRECT[Redirect to HTTPS]
    HTTPS -->|Yes| AUTH{Needs Auth?}
    
    AUTH -->|No| CSRF{Needs CSRF?}
    AUTH -->|Yes| JWT{Valid JWT?}
    
    JWT -->|No| UNAUTH[‚ùå 401 Unauthorized]
    JWT -->|Yes| AUTHZ{Authorized?}
    
    AUTHZ -->|No| FORBID[‚ùå 403 Forbidden]
    AUTHZ -->|Yes| CSRF
    
    CSRF -->|No| PROCESS[Process Request]
    CSRF -->|Yes| CSRF_VALID{Valid CSRF?}
    
    CSRF_VALID -->|No| CSRF_FAIL[‚ùå CSRF Failed]
    CSRF_VALID -->|Yes| XSS[XSS Detection]
    
    XSS -->|Suspicious| LOG[Log & Block]
    XSS -->|Safe| PROCESS
    
    PROCESS --> SUCCESS[‚úÖ Success]
    
    style START fill:#e1f5fe
    style SUCCESS fill:#e8f5e8
    style RATE_BLOCK fill:#fff3e0
    style BLOCK1 fill:#ffebee
    style UNAUTH fill:#ffebee
    style FORBID fill:#ffebee
    style CSRF_FAIL fill:#ffebee
    style LOG fill:#fff3e0
```

## üö¶ Fluxo de Rate Limiting

```mermaid
flowchart TD
    START([Requisi√ß√£o Recebida]) --> RATE_CHECK{Rate Limit Check}
    
    RATE_CHECK -->|Within Limits| AUTH_CHECK[Continue to Auth]
    RATE_CHECK -->|Exceeded| POLICY_CHECK{Which Policy?}
    
    POLICY_CHECK -->|GeneralPolicy| GENERAL[100 req/min<br/>Sliding Window]
    POLICY_CHECK -->|AuthPolicy| AUTH_POLICY[5 req/5min<br/>Fixed Window]
    POLICY_CHECK -->|StrictPolicy| STRICT[Token Bucket<br/>10 tokens, 2/30s]
    POLICY_CHECK -->|ConcurrencyPolicy| CONCURRENCY[5 simultaneous<br/>per IP]
    POLICY_CHECK -->|GlobalLimiter| GLOBAL[200 req/min<br/>per IP fallback]
    
    GENERAL --> BLOCK[‚ùå 429 Rate Limited]
    AUTH_POLICY --> BLOCK
    STRICT --> BLOCK
    CONCURRENCY --> BLOCK
    GLOBAL --> BLOCK
    
    BLOCK --> LOG[Log Attempt]
    LOG --> HEADERS[Add Retry Headers]
    HEADERS --> RESPONSE[Return 429 Response]
    
    AUTH_CHECK --> CONTINUE[‚úÖ Process Request]
    
    style START fill:#e1f5fe
    style CONTINUE fill:#e8f5e8
    style BLOCK fill:#ffebee
    style LOG fill:#fff3e0
    style GENERAL fill:#f3e5f5
    style AUTH_POLICY fill:#e0f2f1
    style STRICT fill:#fce4ec
    style CONCURRENCY fill:#e8f5e8
    style GLOBAL fill:#fff8e1
```

## üöÄ Como Executar

### Pr√©-requisitos

- .NET 8.0 SDK
- Visual Studio 2022 ou VS Code

### Passos

1. **Clone o reposit√≥rio**

   ```bash
   git clone <repo-url>
   cd authentication-examples
   ```

2. **Configure as settings**

   ```json
   // appsettings.json
   {
     "Jwt": {
       "Key": "sua-chave-super-secreta-de-pelo-menos-32-caracteres",
       "Issuer": "JwtAuthApp",
       "Audience": "JwtAuthApp",
       "ExpirationInHours": 1
     }
   }
   ```

3. **Execute a aplica√ß√£o**

   ```bash
   cd JwtAuthApp
   dotnet run
   ```

4. **Acesse**
   - Aplica√ß√£o: `https://localhost:5001`
   - Swagger: `https://localhost:5001/swagger`

## üß™ Testes de Seguran√ßa

### Testando Autentica√ß√£o JWT

```bash
# 1. Login
curl -X POST https://localhost:5001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"admin123"}'

# 2. Usar token
curl -X GET https://localhost:5001/api/auth/protected \
  -H "Authorization: Bearer <seu-token>"
```

### Testando Prote√ß√£o CSRF

```bash
# 1. Obter token CSRF
curl -X GET https://localhost:5001/api/antiforgery/token

# 2. Usar token CSRF
curl -X POST https://localhost:5001/api/antiforgery/validate \
  -H "X-CSRF-TOKEN: <csrf-token>" \
  -H "Content-Type: application/json" \
  -d '{"test":"data"}'
```

### Testando Prote√ß√£o XSS

- Acesse `/Home/Admin`
- Use o campo "Test XSS Protection"
- Tente inputs como: `<script>alert('xss')</script>`

### Testando Rate Limiting

- Acesse `/Home/RateLimit`
- Use os testes individuais para cada pol√≠tica
- Execute testes de stress para disparar os limites

```bash
# Teste da pol√≠tica geral (100/min)
curl -X GET https://localhost:5001/api/ratelimit/test-general

# Teste da pol√≠tica de auth (5/5min)
curl -X POST https://localhost:5001/api/ratelimit/test-auth \
  -H "Content-Type: application/json" \
  -d '{"test":"data"}'

# Teste de m√∫ltiplas requisi√ß√µes (stress test)
for i in {1..10}; do
  curl -X GET https://localhost:5001/api/ratelimit/test-rapid &
done
```

## üìÅ Estrutura do Projeto

```
JwtAuthApp/
‚îú‚îÄ‚îÄ Controllers/
‚îÇ   ‚îú‚îÄ‚îÄ AuthController.cs          # Autentica√ß√£o JWT
‚îÇ   ‚îú‚îÄ‚îÄ SecurityController.cs      # Testes de seguran√ßa
‚îÇ   ‚îú‚îÄ‚îÄ AntiForgeryController.cs   # Prote√ß√£o CSRF
‚îÇ   ‚îî‚îÄ‚îÄ ErrorController.cs         # Tratamento de erros
‚îú‚îÄ‚îÄ Extensions/
‚îÇ   ‚îú‚îÄ‚îÄ AuthenticationExtensions.cs # Config JWT
‚îÇ   ‚îî‚îÄ‚îÄ AuthorizationExtensions.cs  # Pol√≠ticas
‚îú‚îÄ‚îÄ Middlewares/
‚îÇ   ‚îî‚îÄ‚îÄ ExceptionHandlingMiddleware.cs # Tratamento exce√ß√µes
‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îî‚îÄ‚îÄ AuthService.cs             # L√≥gica de autentica√ß√£o
‚îú‚îÄ‚îÄ wwwroot/js/
‚îÇ   ‚îú‚îÄ‚îÄ xss-protection.js          # Prote√ß√£o XSS frontend
‚îÇ   ‚îú‚îÄ‚îÄ csrf-helper.js             # Helper CSRF
‚îÇ   ‚îî‚îÄ‚îÄ admin-functions.js         # Fun√ß√µes de teste
‚îî‚îÄ‚îÄ Program.cs                     # Configura√ß√£o principal
```

## üìä Resumo das Prote√ß√µes

| Amea√ßa | Prote√ß√£o Implementada | Status |
|--------|----------------------|---------|
| **XSS** | Headers CSP + Sanitiza√ß√£o + Detec√ß√£o | ‚úÖ |
| **CSRF** | Anti-Forgery Tokens | ‚úÖ |
| **Clickjacking** | X-Frame-Options: DENY | ‚úÖ |
| **MIME Sniffing** | X-Content-Type-Options: nosniff | ‚úÖ |
| **Info Disclosure** | Middleware de exce√ß√µes | ‚úÖ |
| **Unauthorized Access** | JWT + Authorization Policies | ‚úÖ |
| **Input Injection** | Sanitiza√ß√£o + Valida√ß√£o | ‚úÖ |
| **Security Headers** | Middleware personalizado | ‚úÖ |
| **DoS/DDoS** | Rate Limiting (m√∫ltiplas pol√≠ticas) | ‚úÖ |
| **Brute Force** | Rate Limiting + Logging | ‚úÖ |

## üîê Considera√ß√µes de Seguran√ßa

### Em Produ√ß√£o

- [ ] Usar HTTPS sempre (`RequireHttps`)
- [ ] Configurar JWT keys mais robustas
- [ ] Implementar rate limiting
- [ ] Configurar logging detalhado
- [ ] Implementar monitoring de seguran√ßa
- [ ] Usar secrets management (Azure Key Vault, etc.)

### Monitoramento

- [ ] Alertas para tentativas de XSS
- [ ] Monitoramento de falhas de autentica√ß√£o
- [ ] An√°lise de padr√µes de ataques
- [ ] Dashboard de seguran√ßa

---

## üë• Contribui√ß√£o

Para contribuir com este projeto:

1. Fork o reposit√≥rio
2. Crie uma branch para sua feature
3. Implemente com testes de seguran√ßa
4. Documente as mudan√ßas
5. Submeta um Pull Request

## üìÑ Licen√ßa

Este projeto √© distribu√≠do sob a licen√ßa MIT. Consulte o arquivo `LICENSE` para mais detalhes.

---

**‚ö†Ô∏è Importante**: Este projeto √© para fins educacionais e demonstra√ß√£o de conceitos de seguran√ßa. Para uso em produ√ß√£o, realize auditoria de seguran√ßa completa e siga as melhores pr√°ticas espec√≠ficas do seu ambiente.
